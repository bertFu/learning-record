# JavaScript - 引用类型

引用类型与传统面向对象程序设计中的类相似，但实现不同

> 对象在 JavaScript 中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象

## Object

> Object 是一个基础类型，其他所有类型都从 Object 继承了基础行为

```javascript
var person = new Person();
person.name = "Bert";
person.age = 29;

var person = {
  name: "Bert",
  age: 29
}
```

两种创建对象的方式是等价的

```javascript
var person = {
  name: "Bert",
  age: 29,
  5: true
}
```

这段代码创建的对象：`person` 中含有三个属性：name、age和5.这里的5会被自动转换为字符串

```javascript
// 下面两种访问对象属性的方法没有任何区别
alert(person["name"]);  // Bert
alert(person.name); // Bert

// 使用括号语法的有点是可以通过变量来访问属性
var propertyName = "name";
alert(person[propertyName]);  // Bert

// 属性名中包含特殊字符时无法使用 '.' 访问，这时候可以使用 '[]' 来访问或赋值
person["first name"] = "Bert"
```

## Array

> Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能

```javascript
// 创建一个数组，长度为0
var colors = new Array();
var colors = [];

// 创建一个数组，长度为2
var colors = new Array(2);
var colors = [, ,]; // 这种方式会有兼容问题

// 创建一个数组，内容为 ["red", "blue", "green"]
var colors = new Array("red", "blue", "green");
var colors = ["red", "blue", "green"];
```

### length 使用小技巧

> length 表示数组的长度，会始终返回0或更大的值

数据的 `length` 属性不是只读的。因此，通过设置这个属性，可以从数组的末尾移除或想数组末尾添加新项：

```javascript
var colors = ["red", "blue", "green"];
colors.length = 2;
alert(colors[2]); // undefined
```

colors 数组一开始有三个值，将 length 的长度设为2会移除最后一项，再访问 colors[2] 时，原本的 'green' 被移除了，输出 undefined

```javascript
var colors = ["red", "blue", "green"];
colors.length = 4;
alert(colors[4]); // undefined
```

同理将数组的长度设置为4，超出的位置的值默认会设置为 undefined

```javascript
var colors = ["red", "blue", "green"];
colors[colors.length] = "black";
colors[colors.length] = "brown";
alert(colors); // ["red", "blue", "green", "black", "brown"]
```

数组的最后一项的下标为 `length-1` ，因此对 `length` 下标赋值数组会在最后一个位置新增对应值

### Array 的常用方法

- toLocaleString()： 默认情况下会以逗号分隔的字符串的形式返回数组项，需要特别处理数组表现形式时使用
- toString()： 默认情况下会以逗号分隔的字符串的形式返回数组项，使用输出语句时会默认调用 toString 方法
- valueOf()： 默认情况下会以逗号分隔的字符串的形式返回数组项，使用判断语句时会默认调用 valueOf 方法
- join(Str)：不传参数或传入 undefined 会默认使用逗号作为分隔符输出，传入参数则以参数作为分隔符输出

  ```javascript
  var colors = ["red", "black"];
  alert(colors.join()); // red,black
  alert(colors.join("-")); // red-black
  ```

- push()：接受任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组的长度

  ```javascript
  var colors = new Array();
  var count = colors.push("red", "black");
  alert(count); // 2
  ```

- pop()：从数组末尾移除最后一项，并返回移除的项

  ```javascript
  var colors = ["red", "black", "blue"];
  var item = colors.pop();
  alert(item); // "blue"
  alert(colors.length); // 2
  ```

- shift()：移除数组中的第一项并返回该项

  ```javascript
  var colors = ["red", "black", "blue"];
  var item = colors.shift();
  alert(item); // "red"
  alert(colors.length); // 2
  ```

- unshift()：在数组前端添加任意个项并返回新数组的长度

  ```javascript
  var colors = new Array("red", "black");
  var count = colors.unshift("blue", "green");
  alert(count); // 4
  ```

- reverse()：反转数组项的顺序

  ```javascript
  var values = [1, 2, 3, 4, 5];
  values.reverse();
  alert(values); // 5,4,3,2,1
  ```

- sort()：默认按字符串升序排列，该方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面

  - 比较函数接收两个参数

    - 如果第一个参数应该位于第二个之前则返回一个负数
    - 如果两个参数相等则返回0
    - 如果第一个参数应该位于第二个之后则返回一个正数

  ```javascript
  var values = [0, 1, 5, 10, 15];
  values.sort()
  alert(values); // 0,1,10,15,5
  ```

  sort 方法默认是已字符串进行比较

  ```javascript
  function compare(value1, value2) {
    if (value1 < value2) {
      return -1;
    } else if (value1 > value2) {
      return 1;
    } else {
      return 0;
    }
  }

  var values = [0, 1, 5, 10, 15];
  values.sort(compare);
  alert(values); // 0,1,5,10,15
  ```

- concat()：可以基于当前数组中的所有项创建一个新数组，这个方法会先创建一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组

  - 参数是一个或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中
  - 如果传递的值不是数组，这些值就会被简单的添加到结果数组的末尾

  ```javascript
  var colors = ["red", "blue", "green"];
  var colors2 = colors.concat("yellow", ["black"], "brown")
  alert(colors); // red,blue,green
  alert(colors2); // red,blue,green,yellow,black,brown
  ```

- slice()：基于当前数组中的一或多个项创建一个新数组（不会影响到原数组）

  - 该方法可以接受一个或两个参数，即要返回项的起始和结束为止

    - 在只有一个参数的情况下，slice()方法返回从该参数指定为止开始到当前数组末尾的所有项
    - 如果有两个参数，该方法返回起始和结束位置之间的项 ---- 但不包括结束位置的项

  ```javascript
  var color = ["red", "green", "blue", "yellow", "purple"];
  var color2 = colors.slice(1);
  var color3 = colors.slice(1, 4);
  alert(colors2); // green,blue,yellow,purple
  alert(colors3); // green,blue,yellow
  ```

  > 如果 slice() 方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含5项的数组上调用 slice(-2, -1) 与调用 slice(3, 4) 的到的结果相同。如果结束位置小于起始位置，则返回空数组

- splice()：数组中最牛逼的方法，他的主要用途是向数组的中部插入项

  - 删除：可以删除任意数量的项，只需要指定两个参数：需要删除的第一项的位置和要删除的项数。例如：`splice(0, 2)`会删除数组中的前两个项
  - 插入：可以向制定位置插入任意数量的项，只需要提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项

    - 例如：`splice(2, 0, "red", "green")` 会从当前数组的位置2开始插入字符串 "red" 和 "green"

  - 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需要指定3个参数：其实位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等

    - 例如：`splice(2, 1, "red", "green")`会删除单签数组位置2的项，然后再从位置2开始插入字符串"red"， "green"

  - splice() 方法始终会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）

  ```javascript
  var color = ["red", "green", "blue"];

  // 删除第一项
  var removed = colors.splice(0, 1);
  alert(colors); // green, blue
  alert(removed); // red, 返回的数组中只包含一项

  removed = colors.splice(1, 0, "yellow", "orange"); // 从位置1开始插入两项
  alert(colors); // green, yellow, orange, blue
  alert(removed); // []

  removed = colors.splice((1, 1, "red", "purple"))
  alert(colors); // green, red, purple, orange, blue
  alert(removed); // yellow
  ```

- indexOf()：从头开始向末尾查找，接受两个参数：要查找的项和（可选的）表示查找启动位置的索引

  - 没有找到返回 -1
  - 找到返回数组的下标
  - 查找的项必须严格相等（===）

- lastIndexOf()：从末尾开始向前查找，接受两个参数：要查找的项和（可选的）表示查找启动位置的索引

  - 没有找到返回 -1
  - 找到返回数组的下标
  - 查找的项必须严格相等（===）

```javascript
var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

// 传入一个参数，表示查找的项
alert(numbers.indexOf(4)) // 3
alert(numbers.lastIndexOf(4)) // 5

// 传入两个参数
alert(numbers.indexOf(4, 4)) // 5
alert(numbers.lastIndexOf(4, 4)) // 3

// 查询对象
var person = {name: "Bert"};
var people = [{name: "Bert"}];
var morePeople = [person];
alert(people.indexOf(person)) // -1
alert(morePeople.indexOf(person)) // 0
```

- every()：遍历数组，如果传入的函数每一项都返回 true 该方法会返回true，如果有一项返回false，则该方法返回 false（数组每项的 && 的关系）
- some()：遍历数组，如果传入的函数每一项都返回 false 该方法会返回 false，如果有一项返回 true，则该方法返回 true （数组每项的 || 的关系）

  ```javascript
  var numbers = [1,2,3,4,5,4,3,2,1];
  var everyResult = numbers.every(function(item. index, array) {
    return (item > 2);
  })
  alert(everyResult) // false

  var someResult = numbers.some(function(item, index, array) {
    return (item > 2);
  })
  alert(someResult); // true
  ```

- filter()：遍历数组，将传入的函数的返回 true 的项值重新生成新数组，过滤返回 false 的项（数组的过滤器，用于搜索）

  ```javascript
  var numbers = [1,2,3,4,5,4,3,2,1];
  var filterResult = numbers.filter(function(item, index, array) {
    return (item > 2);
  })
  alert(filterResult); // [3,4,5,4,3]
  ```

- forEach()：针对数组的每一项运算传入的函数，没有返回值

- map()：遍历数组，将传入的函数的返回值作为新的数组的值

  ```javascript
  var numbers = [1,2,3,4,5,4,3,2,1];
  var mapResult = numbers.map(function(item, index, array) {
    return item * 2;
  })

  alert(mapResult); // [2,4,6,8,10,8,6,4,2]
  ```

- reducer()：方法可以执行求数组中所有值之和的操作，会将前一次返回的结果作为下一次运算的第一个参数（数组的递归运算）

  ```javascript
  var values = [1,2,3,4,5];
  var sum = values.reduce(function(prev, cur, index, array) {
    return prev + cur;
  })
  alert(sum); //15
  ```

- reducerRight()：与 reducer 作用类似，只不过方向相反（数组的反向递归）

  ```javascript
  var values = [1,2,3,4,5];
  var sum = values.reduceRight(function(prev, cur, index, array) {
    return prev + cur;
  })
  alert(sum); //15
  ```

## Date

> - Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能

创建日期对象：

```javascript
var now = new Date();
```

构造函数不传参数情况下，新对象自动获得当前日期和时间

如果想要更具特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC时间1970年1月1日午夜起至该日期止经过的毫秒数）

为了简化这一计算过程，ECMAScript 提供了两个方法：

- Date.parse()：该方法接受一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数

  - ECMA-262没有定义 Date.parse() 应该支持那种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异
  - "月/日/年"，如 "6/13/2004"
  - "因为月名 日，年"，如 "January 12,2004"
  - "因为星期几 因为月名 日 年 时:分:秒 时区"，如 "TueMay 25 2004 00:00:00 GMT-0770"
  - ISO 8601扩展格式YYYY-MM-DDTHH:mmSS.SSZ (例如："2004-05-25T00:00:00")。只有兼容ECMAScript 5的实现支持这种格式

    > 在一次项目的扩展中，使用 YYYY-MM-DDTHH:mmSS.SSZ 这个格式在 Safari 上就出现无法解析的问题，解决方式是把 '-' 转 成 '/'

  ```javascript
  // 创建 2004年5月25日的一个日期对象
  var someDate = new Date(Date.parse("May 25,2004"));

  // 如果传入Date.parse() 方法的字符串不能表示日期，那么它会返回NAN。实际上，如果直接将表示日期的字符创传递给Date构造函数，也会在后台调用 Date.parse()：
  var someDate = new Date("May 25,2004"); // 这句代码与上句代码是等价的
  ```

  > 日期对象在不同浏览器中的实现有许多起卦的行为。其中有一种倾向是将超出范围的值替换成当前值，以便生成输出。

  > 例如：在接续 "January 32,2007"时，有的浏览器会将其解释为 "February 1,2007"。而Opera则倾向于插入当前月份的当前日期，返回 "January当前日期，2007"。

  > 也就是说，如果在2007年9月21日运行前面的代码，将会得到 "January 21,2007"（都是21日）

- Date.UTC()：

> Date.UTC()方法同样也返回表示日期的毫秒数，但它与 Date.parse() 在构建值时使用不同的信息

- 参数一：年份、基于0的月份（一月是0，二月是1，以此类推）
- 参数二：月中的哪一天（1到31）
- 参数三：小时数（0到23）
- 参数四：分钟
- 参数五：秒
- 参数六：毫秒数

在这些参数中只有前两个参数（年和月）是必需的。

```javascript
// GMT时间2000年1月1日午夜零时
var y2k = new Date(Date.UTC(2000, 0));

// GMT时间2005年5月5日下午5.:55:55
var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));

// 本地时间2000年1月1日午夜零时
var y2k_1 = new Date(2000, 0);

// 本地时间2005年5月5日下午5:55:55
var allFives_1 = new Date(2005, 4, 5, 17, 55, 55);
```

ECMAScript 5 添加了 Date.now() 方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用Date对象分析代码的工作

```javascript
// 取得开始时间
var start = Date.now();

// 调用函数
doSomething()

// 取得停止时间
var stop = Date.now(),
    result = stop - start;
```

获取一个方法的执行时间毫秒值

支持 Date.now() 方法的浏览器包括 IE9+、Firefox 3+、Safari 3+、Opera 10.5和Chrome。

```javascript
// 取得开始时间
var start = +new Date();

// 调用函数
doSomething()

// 取得停止时间
var stop = +new Date();
    result = stop - start;
```

在不支持 Date.now() 方法的浏览器中，使用 '+' 操作符把Data对象转换成字符串，也可以得到毫秒值

### 比较 Date 的大小

Date 类型的 ValueOf() 方法，不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符（大于或小于）来比较日期值。

```javascript
var date1 = new Date(2007, 0, 1);
var date2 = new Date(2007, 1, 1);

alert(date1 < date2) // true
alert(date1 > date2) // false
```

### 日期格式化

Date 类型还有一些专门用于将日期格式化为字符串的方法：

- toDateString()：`new Date().toDateString() // "Tue Oct 18 2016"`
- toTimeString()：`new Date().toTimeString() // "23:29:12 GMT+0800 (CST)"`
- toLocaleDateString()：`new Date().toLocaleDateString() // "2016/10/18"`
- toLocaleTimeString()：`new Date().toLocaleTimeString() // "下午11:30:28"`
- toUTCString()：`new Date().toUTCString() // "Tue, 18 Oct 2016 15:30:53 GMT"`

### 日期/时间组件方法

方法                   | 说明
:------------------- | :--------------------------------------------------------
getTime()            | 返回表示日期的毫秒数：与valueOf()方法返回的值相同
setTime(毫秒)          | 以毫秒数设置日期，会改变整个日期
getFullYear()        | 获取四位数的年丰（如 2007而非07）
getUTCFullYear()     | 返回UTC日期的4位数年份
setFullYear(年)       | 设置日起的年份，传入的年分支必须是4为数字（如 2007而非07)
setUTCFullYear(年)    | 设置UTC日期的年份。传入的年份值必须是4位数字（如 2007而非07)
getMonth()           | 返回日期中的月份，其中0表示一月，11表示十二月
getUTCMonth()        | 返回UTC日期中的月份，其中0表示一月，11表示十二月
setMonth()           | 设置日期的月份。传入的月份值必须大于0，超过11则增加年份
setUTCMonth()        | 设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份
getDate()            | 返回日期月份中的天数（1到31）
getUTCDate()         | 返回UTC日期月份中的天数（1到31）
setDate()            | 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
setUTCDate(日)        | 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
getDay()             | 返回日期中清气得星期几（其中0表示星期日，6表示星期六）
getUTCDay()          | 返回UTC日期中清气得星期几（其中0表示星期日，6表示星期六）
getHours()           | 返回日期中的小时数（0到23）
getUTCHours()        | 返回UTC日期中的小时数（0到23）
setHours(时)          | 设置日期中的小时数，传入的超过了23则增加月份中的天数
setUTCHours(时)       | 设置UTC日期中的小时数，传入的超过了23则增加月份中的天数
getMinutes()         | 返回日期中的分钟数（0到59）
getUTCMinutes()      | 返回UTC日期中的分钟数（0到59）
settMinutes(分)       | 设置日期中的分钟数。传入的值超过59则增加小时数
settUTCMinutes(分)    | 设置UTC日期中的分钟数。传入的值超过59则增加小时数
getSeconds()         | 返回日期中的秒数（0到59）
getUTCSeconds()      | 返回UTC日期中的秒数（0到59）
setSeconds(秒)        | 设置日期中的秒数，传入的值超过59则增加分钟数
setUTCSeconds(秒)     | 设置UTC日期中的秒数，传入的值超过59则增加分钟数
getMillSeconds()     | 返回日期中的毫秒数
getUTCMillSeconds()  | 返回UTC日期中的毫秒数
settMillSeconds()    | 设置日期中的毫秒数
settUTCMillSeconds() | 设置UTC日期中的毫秒数
getTimezoneOffset()  | 返回本地时间与UTC时间相差的分钟数。例如：美国东部标准时间返回300。在某地进入夏令时的情况下，这个值会有所变化

## RegExp

> - RegExp 类型是 ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能

函数实际上是 Function 类型的实例，因此函数也是对象；而这一点整是 JavaScript 最有特色的地方。由于函数对象，所以函数也拥有方法，可以用来争抢其行为

因为有了基本包装类型，所以 JavaScript 中的基本类型值可以被当做对象来访问，三种基本包装类型分别是：Boolean、Number和String

- 每个包装类型都映射到同名的基本类型
- 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作
- 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象

在所有代码执行之前，作用域中就已经存在两个内置对象：Global 和 Math 。在大多数 ECMAScript 实现中都不能直接访问 Global 对象；不过，Web 浏览器实现了承担该角色的 window 对象。全局变量和函数都是 Global 对象的属性。Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务

### 创建正则表达式

```javascript
var expression = / pattern / flags ;
var expression1 = new RegExp('pattern', flags);
```

使用类似Perl的语法，可以创建一个正则表达式

其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。

- g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
- i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
- m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在于模式匹配的项；

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。

```javascript
/*
  正则表达式包括：

  ( [ { / ^ $ | ? * + . } ] )

  这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义
*/


// 匹配字符串中所有 'at' 的实例
var pattern1 = /at/g;


// 匹配第一个'bat' 或 'cat', 不区分大小写
var pattern2 = /[bc]at/i;

// 匹配第一个'[bc]at', 不区分大小写
var pattern2 = /\[bc\]at/i;


// 匹配所有以 ' at' 结果的3个字符的组合，不区分大小写
var pattern3 = /. at/gi;

// 匹配所有以 '.at'，不区分大小写
var pattern3 = /\. at/gi;
```

字面量模式          | 等价的字符串
:------------- | :----------------------
/[bc]at/       | `"\\[bc\\]at"`
/.at/          | `"\\.at"`
/name\/age/    | `"name\\/age"`
/\d.\d{1, 2}/  | `"\\d.\\d{1, 2}"`
/\w\hello\123/ | `"\\w\\\\hello\\\\123"`

> 字符串 `\` 在字符串中通常被转义为 `\\`, 而在正则表达式字符串中就会变成 `\\\\`

```javascript
var re = null, i;

for (i=0; i > 10; i++) {
  re = /cat/g;
  re.test("catastrophe");
}

for (i=0; i > 10; i++) {
  re = new RegExp("cat", "g");
  re.test("catastrophe");
}
```

test() 方法用来匹配传入的字符串是否符合正则表达式

ECMAscript 5 之前 使用字面量不是创建一个新的正则表达式实例，有点像单例模式，会导致循环调用test时失败的情况。

ECMAScript 5 明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp示例。IE9、Fiefox 4+、和Chrome都据此做出了修改

### RegExp 实例属性

> RegExp 对象的主要方法是 exec()， 该方法是专门为捕获组而设计的。 exec() 接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null

> 返回的数组虽然是Array的实例，但包含两个额外的属性：index 和 input。

> 其中 index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。

> 在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。

```javascript
var text = "mom and dad and baby";
var pattern = /mom( and dad( and baby)?)?/gi;

var matches = pattern.exec(text);
alert(matches.index);
alert(matches.input);

alert(matches[0]);
alert(matches[1]);
alert(matches[2]);
```

这个实例中包含两个捕获组。 `()`

最内部的捕获组匹配 "and baby"，而包含它的捕获组匹配 "ant dad" 或者 "and dad and baby"。

当把字符串传入 exec() 方法中之后，发现了一个匹配项。

因为整个字符串本身与模式匹配，所以返回的数组 matchs 的 index 属性值为 0。

数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。

> 对于 exec() 方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。

> 在不设置全局标志的情况下，在同一个字符串上多次调用 exec() 将始终返回第一个匹配项的信息。

> 而在设置全局标志的情况下，每次调用 exec() 则都会在字符串中继续查找新的匹配项。
