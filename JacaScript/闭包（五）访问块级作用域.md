# 访问块级作用域

JavaScript 没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的。

```javascript
function outputNumbers(count) {
    for(var i=0; i < count; i++) {
        alert(i);
    }

    alert(i); // 计数
}
```

上例函数中定义了一个 for 循环，而变量i的初始值被设置为0.在 Java、C++等语言中，变量i只会在 for 循环的语句块中有定义，循环一旦结束，变量i就会被销毁。可是在 JavaScript 中，变量i是定义在 outputNumbers() 的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它。即使重新声明同一个变量，也不会改变它的值。

```javascript
function outputNumbers(count) {
    for(var i=0; i < count; i++) {
        alert(i);
    }

    var i; // 重新声明变量
    alert(i); // 计数
}
```

JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。匿名函数可以使用模仿块级作用域并避免这个问题。

用作块级作用域（通常称为私有作用域）的匿名函数的语法：

```javascript
(function() {
    // 这里是块级作用域
})();
```

上例代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。

```
var count = 5;
outputNumbers(count);

// 等价于
outputNumbers(5);
```

这里初始化变量 count，将其值设置为5.当然这里的变量是没有必要的，因为可以把值直接传给函数。为了让代码更简洁，我们在调用函数时用5来代替变量 count。

这样做之所以可行，是因为变量只不过是值的另一种表现形式，因此用实际的值代替变量没有问题。

```
var someFunction = function() {
    // 这里是块级作用域
}

someFunction();

// 等价于
(function() {
    // 这里是块级作用域
})();

// 错误
function() {
    // 这里是块级作用域
}();
```
